## 1. Jump Game VII

**Problem**:  
You are given a binary string `s` and integers `minJump`, `maxJump`.

- Start at index `0` (always `'0'`).
- You can jump from index `i` to index `j` if:
  - \(i + \text{minJump} \leq j \leq \min(i + \text{maxJump}, s.length - 1)\)
  - and `s[j] == '0'`.  
    Return `true` if you can reach the last index, else `false`.

---

### ğŸ” Core Idea: Dynamic Programming with Sliding Window

- Use a boolean array `db[]` to track reachable indices.
- For each reachable index `i`:
  - Mark all valid positions `j` in range `[i+minJump â€¦ i+maxJump]` as reachable if `s[j] == '0'`.
- Optimize by maintaining a sliding window (`start`, `end`) to avoid redundant checks.
- Stop early if last index becomes reachable.

---

### ğŸ§  Algorithm Breakdown

#### Step 1: Initialization

- `db[0] = true` (starting point).
- `start = 0`, `end = 0`.

#### Step 2: Traverse String

- For each index `i`:
  - If `db[i] == false` â†’ skip.
  - Update window:
    - `start = max(i + minJump, end + 1)`
    - `end = min(i + maxJump, n-1)`
  - For each `j` in `[startâ€¦end]`:
    - If `s[j] == '0'` â†’ mark `db[j] = true`.
  - If `db[n-1] == true` â†’ return `true`.

#### Step 3: Return Result

- After loop, return `db[n-1]`.

---

### âœ… Example Walkthrough

```text
s = "011010", minJump = 2, maxJump = 3

â†’ Start at index 0
   From 0 â†’ can jump to [2,3]
   Index 3 reachable
   From 3 â†’ can jump to [5,6]
   Index 5 reachable
â†’ Last index (5) reachable â†’ true âœ…
```

```text
s = "01101110", minJump = 2, maxJump = 3

â†’ Start at index 0
   From 0 â†’ can jump to [2,3]
   Index 2 is '1' â†’ not valid
   Index 3 is '0' â†’ reachable
   From 3 â†’ can jump to [5,6]
   Both are '1' â†’ blocked
â†’ Last index unreachable â†’ false âœ…
```

---

### ğŸ“ Complexity

| Aspect    | Value                                                |
| --------- | ---------------------------------------------------- |
| Time      | O(n) (each index processed once with sliding window) |
| Space     | O(n) (boolean array for reachability)                |
| Technique | Dynamic programming + sliding window                 |

---

### ğŸ” Pattern

- Reachability problems with constraints
- Similar to BFS/DP on string indices
- Sliding window optimization to avoid redundant checks

---

### ğŸš€ Alternative Approaches

- **Breadth-First Search (BFS)**: Treat indices as graph nodes, explore reachable positions.
- **Greedy + Queue**: Maintain frontier of reachable indices.
- **Segment Tree / Fenwick Tree**: For larger constraints, optimize range updates.

---

### âš ï¸ Edge Cases

- `s = "0"` â†’ trivially true.
- `s` with all `'0'` â†’ always reachable.
- `s` with blocking `'1'` at critical positions â†’ false.
- Large input (`10^5`) â†’ efficient with O(n).

ğŸ”— [LeetCode â€“ Jump Game VII](https://leetcode.com/problems/jump-game-vii)

---

## 2. Split Two Strings to Make Palindrome

**Problem**:  
Given two strings `a` and `b` of equal length, choose an index and split both strings at that index:

- `a = aprefix + asuffix`
- `b = bprefix + bsuffix`

Check if either `aprefix + bsuffix` or `bprefix + asuffix` forms a palindrome.  
Return `true` if possible, else `false`.

---

### ğŸ” Core Idea: Two-Pointer Matching + Palindrome Check

- Traverse from both ends (`i` from start, `j` from end).
- Compare characters from `a` (prefix) and `b` (suffix).
- Stop when mismatch occurs.
- At mismatch, check if the remaining substring in either `a` or `b` is a palindrome.
- If yes â†’ return `true`.
- Otherwise â†’ return `false`.
- Repeat the process swapping roles of `a` and `b`.

---

### ğŸ§  Algorithm Breakdown

#### Step 1: Main Function

- `checkPalindromeFormation(a, b)` â†’ returns `check(a, b) || check(b, a)`.

#### Step 2: Check Function

- Initialize `i = 0`, `j = a.length()-1`.
- While `i < j` and `a[i] == b[j]`: move inward (`i++`, `j--`).
- If pointers cross (`i >= j`) â†’ palindrome possible â†’ return `true`.
- Else â†’ check if substring `a[iâ€¦j]` or `b[iâ€¦j]` is palindrome.

#### Step 3: Palindrome Helper

- `isPalin(s, start, end)` â†’ standard two-pointer palindrome check.
- Return `true` if substring is palindrome, else `false`.

---

### âœ… Example Walkthrough

```text
a = "x", b = "y"

â†’ aprefix = "", asuffix = "x"
â†’ bprefix = "", bsuffix = "y"
â†’ "" + "y" = "y" â†’ palindrome
â†’ Result = true âœ…
```

```text
a = "xbdef", b = "xecab"

â†’ Compare from ends:
   mismatch leads to substrings "bdef" and "xecab"
   neither forms palindrome
â†’ Result = false âœ…
```

```text
a = "ulacfd", b = "jizalu"

â†’ Split at index 3:
   aprefix = "ula", asuffix = "cfd"
   bprefix = "jiz", bsuffix = "alu"
â†’ aprefix + bsuffix = "ulaalu" â†’ palindrome
â†’ Result = true âœ…
```

---

### ğŸ“ Complexity

| Aspect    | Value                                      |
| --------- | ------------------------------------------ |
| Time      | O(n) (two-pointer scan + palindrome check) |
| Space     | O(1) (constant extra space)                |
| Technique | Two-pointer + palindrome validation        |

---

### ğŸ” Pattern

- Palindrome problems with conditional splits
- Two-pointer traversal for efficiency
- Similar to "Valid Palindrome II" (allowing one mismatch)

---

### ğŸš€ Alternative Approaches

- **Brute force**: Try all split indices â†’ O(nÂ²).
- **Optimized two-pointer**: Current approach â†’ O(n).
- **String reversal**: Compare prefix with reversed suffix, but less clean.

---

### âš ï¸ Edge Cases

- Single-character strings â†’ always palindrome.
- Already palindrome strings â†’ return `true`.
- No valid split â†’ return `false`.
- Large strings (up to 100,000 chars) â†’ efficient with O(n).

ğŸ”— [LeetCode â€“ Split Two Strings to Make Palindrome](https://leetcode.com/problems/split-two-strings-to-make-palindrome)

---
